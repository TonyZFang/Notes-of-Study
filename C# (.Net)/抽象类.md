抽象类

abstract 修饰符用于表示所修饰的类是不完整的，并且它只能用作基类。抽象类与非抽象类在以下方面是不同的：
抽象类不能直接实例化，并且对抽象类使用 new 运算符是编译时错误。虽然一些变量和值在编译时的类型可以是抽象的，但是这样的变量和值必须或者为 null，或者含有对非抽象类的实例的引用（此非抽象类是从抽象类派生的）。
允许（但不要求）抽象类包含抽象成员。 抽象类不能被密封。
当从抽象类派生非抽象类时，这些非抽象类必须具体实现所继承的所有抽象成员，从而重写那些抽象成员。在下面的示例中
abstract class A
{
public abstract void F();
}
abstract class B: A
{
public void G() {}
}
class C: B
{
public override void F() {
// actual implementation of F
}
}

抽象类 A 引入抽象方法 F。类 B 引入另一个方法 G，但由于它不提供 F 的实现，B 也必须声明为抽象类。类 C 重写 F，并提供一个具体实现。由于 C 中没有了抽象成员，因此可以（但并非必须）将 C 声明为非抽象类。

abstract 修饰符可以和类、方法、属性、索引器及事件一起使用。
在类声明中使用 abstract 修饰符以指示类只能是其他类的基类。
抽象类具有以下特性：
抽象类不能实例化。
抽象类可以包含抽象方法和抽象访问器。
不能用 sealed 修饰符修改抽象类，这意味着该类不能被继承。
从抽象类派生的非抽象类必须包括继承的所有抽象方法和抽象访问器的实实现。
在方法或属性声明中使用 abstract 修饰符以指示此方法或属性不包含实现。
抽象方法具有以下特性：
抽象方法是隐式的 virtual 方法。
只允许在抽象类中使用抽象方法声明。
因为抽象方法声明不提供实实现，所以没有方法体；方法声明只是以一个分号结束，并且在签名后没有大括号 ({ })。例如：
public abstract void MyMethod();实现由 overriding 方法提供，它是非抽象类的成员。
在抽象方法声明中使用 static 或 virtual 修饰符是错误的。
除了在声明和调用语法上不同外，抽象属性的行为与抽象方法一样。
在静态属性上使用 abstract 修饰符是错误的。
在派生类中，通过包括使用 override 修饰符的属性声明可以重写抽象的继承属性。
抽象类必须为所有接口成员提供实现。
实现接口的抽象类可以将接口方法映射到抽象方法上。

例如：
interface I
{
void M();
}
abstract class C: I
{
public abstract void M();
}

原文链接:https://www.cnblogs.com/luzhiping/archive/2009/06/19/1506659.html
